<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Multi-Finger Magic</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; font-family: sans-serif; }
        #preview {
            position: absolute; bottom: 10px; right: 10px;
            width: 100px; height: 75px; border: 1px solid #0ff;
            border-radius: 5px; z-index: 20; transform: scaleX(-1);
        }
        #ui {
            position: absolute; top: 15px; width: 100%; text-align: center;
            color: #0ff; z-index: 10; pointer-events: none;
        }
        #gesture-label { font-weight: bold; font-size: 1.5rem; color: #fff; display: block; margin-top: 5px;}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="ui">
        <div id="status">WAITING...</div>
        <div id="gesture-label">NO HAND</div>
    </div>
    <canvas id="preview"></canvas>
    <video id="input_video" playsinline></video>

<script>
    const PARTICLE_COUNT = 4500;
    const videoElement = document.getElementById('input_video');
    const previewCanvas = document.getElementById('preview');
    const previewCtx = previewCanvas.getContext('2d');
    const gestureLabel = document.getElementById('gesture-label');

    // --- THREE.JS ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 40;
    const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- PARTICLES ---
    const geometry = new THREE.BufferGeometry();
    const posArr = new Float32Array(PARTICLE_COUNT * 3);
    const targetArr = new Float32Array(PARTICLE_COUNT * 3);
    const colorArr = new Float32Array(PARTICLE_COUNT * 3);
    
    for(let i=0; i<PARTICLE_COUNT*3; i++) posArr[i] = (Math.random()-0.5)*100;

    geometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colorArr, 3));
    
    const material = new THREE.PointsMaterial({size: 0.7, vertexColors: true, transparent: true, opacity: 0.8});
    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // --- MATH SHAPES ---
    function setShape(type) {
        for(let i=0; i<PARTICLE_COUNT; i++) {
            let x, y, z;
            if(type === 'heart') {
                const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                x = 16 * Math.pow(Math.sin(t), 3);
                y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
                z = (Math.random()-0.5)*5;
            } else if(type === 'point') {
                x = (Math.random()-0.5)*2; y = (Math.random()-0.5)*2; z = (Math.random()-0.5)*2;
            } else { // Explosion/Cloud
                x = (Math.random()-0.5)*60; y = (Math.random()-0.5)*60; z = (Math.random()-0.5)*60;
            }
            targetArr[i*3] = x; targetArr[i*3+1] = y; targetArr[i*3+2] = z;
        }
    }

    setShape('cloud');

    // --- GESTURE LOGIC ---
    let hX = 0, hY = 0, currentGesture = "NONE";
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5 });

    hands.onResults((results) => {
        previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            hX = (0.5 - lm[9].x) * 60;
            hY = (0.5 - lm[9].y) * 40;

            // FINGER DETECTION (Tip vs Joint)
            const indexUp = lm[8].y < lm[6].y;
            const middleUp = lm[12].y < lm[10].y;
            const ringUp = lm[16].y < lm[14].y;
            const pinkyUp = lm[20].y < lm[18].y;

            let upCount = [indexUp, middleUp, ringUp, pinkyUp].filter(v => v).length;

            if (upCount === 0) {
                currentGesture = "FIST";
                setShape('point'); // Squeeze
            } else if (upCount === 1 && indexUp) {
                currentGesture = "POINTING";
                setShape('point'); // Swarm tip
            } else if (upCount === 2 && indexUp && middleUp) {
                currentGesture = "PEACE (HEART)";
                setShape('heart'); 
            } else if (upCount >= 4) {
                currentGesture = "OPEN PALM";
                setShape('cloud');
            }
            gestureLabel.innerText = currentGesture;
        } else {
            gestureLabel.innerText = "NO HAND";
            currentGesture = "NONE";
        }
    });

    new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 480, height: 360, facingMode: "user"
    }).start();

    // --- ANIMATION ---
    function animate() {
        requestAnimationFrame(animate);
        const p = geometry.attributes.position.array;
        const c = geometry.attributes.color.array;
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            let idx = i*3;
            let tx = targetArr[idx] + hX;
            let ty = targetArr[idx+1] + hY;
            let tz = targetArr[idx+2];

            p[idx] += (tx - p[idx]) * 0.1;
            p[idx+1] += (ty - p[idx+1]) * 0.1;
            p[idx+2] += (tz - p[idx+2]) * 0.1;

            // Dynamic Colors based on gesture
            if(currentGesture === "FIST") { c[idx]=1; c[idx+1]=0; c[idx+2]=0; } // Red
            else if(currentGesture === "PEACE (HEART)") { c[idx]=1; c[idx+1]=0.4; c[idx+2]=0.7; } // Pink
            else { c[idx]=0; c[idx+1]=1; c[idx+2]=1; } // Cyan
        }
        points.rotation.y += 0.01;
        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>
