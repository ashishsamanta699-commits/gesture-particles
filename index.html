<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Advanced Finger Gestures</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; font-family: sans-serif; }
        #preview {
            position: absolute; bottom: 10px; left: 10px;
            width: 90px; height: 120px; border: 1px solid #555;
            border-radius: 8px; z-index: 20; transform: scaleX(-1);
        }
        #ui {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: #fff; z-index: 10; pointer-events: none;
        }
        .label { font-size: 1.2rem; font-weight: bold; color: #00ffff; text-transform: uppercase; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="ui">
        <div id="status">FINDING HAND...</div>
        <div id="gesture-name" class="label">NONE</div>
    </div>
    
    <canvas id="preview"></canvas>
    <video id="input_video" playsinline></video>

<script>
    const PARTICLE_COUNT = 5000;
    const videoElement = document.getElementById('input_video');
    const previewCanvas = document.getElementById('preview');
    const previewCtx = previewCanvas.getContext('2d');
    const gestureLabel = document.getElementById('gesture-name');

    // --- THREE.JS SCENE ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 50;
    const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- PARTICLES ---
    const geometry = new THREE.BufferGeometry();
    const posArr = new Float32Array(PARTICLE_COUNT * 3);
    const targetArr = new Float32Array(PARTICLE_COUNT * 3);
    const colorArr = new Float32Array(PARTICLE_COUNT * 3);
    
    for(let i=0; i<PARTICLE_COUNT*3; i++) posArr[i] = (Math.random()-0.5)*100;
    geometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colorArr, 3));
    
    const points = new THREE.Points(geometry, new THREE.PointsMaterial({size: 0.8, vertexColors: true}));
    scene.add(points);

    // --- SHAPE GENERATORS ---
    function setShape(type) {
        for(let i=0; i<PARTICLE_COUNT; i++) {
            let x, y, z;
            if(type === 'heart') {
                const t = (i / PARTICLE_COUNT) * Math.PI * 2;
                x = 16 * Math.pow(Math.sin(t), 3);
                y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
                z = (Math.random()-0.5)*5;
            } else if(type === 'sphere') {
                const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                x = Math.cos(theta) * Math.sin(phi) * 18;
                y = Math.sin(theta) * Math.sin(phi) * 18;
                z = Math.cos(phi) * 18;
            } else if(type === 'fist') {
                x = (Math.random()-0.5)*2; y = (Math.random()-0.5)*2; z = (Math.random()-0.5)*2;
            } else if(type === 'triangle') {
                const a = (i / PARTICLE_COUNT) * Math.PI * 2;
                x = Math.cos(a) * (i%3 === 0 ? 20 : 5);
                y = Math.sin(a) * (i%3 === 0 ? 20 : 5);
                z = (i%3) * 10 - 10;
            }
            targetArr[i*3] = x; targetArr[i*3+1] = y; targetArr[i*3+2] = z;
        }
    }

    // --- HAND AI ---
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6 });

    let hX = 0, hY = 0, activeGesture = "none";

    hands.onResults((results) => {
        previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            hX = (0.5 - lm[9].x) * 70;
            hY = (0.5 - lm[9].y) * 50;

            // FINGER LOGIC: Detect which finger is "Up"
            const isUp = (tip, pip) => lm[tip].y < lm[pip].y;
            const index = isUp(8, 6), middle = isUp(12, 10), ring = isUp(16, 14), pinky = isUp(20, 18);
            const count = [index, middle, ring, pinky].filter(Boolean).length;

            if (count === 0) { activeGesture = "fist"; setShape('fist'); }
            else if (count === 1 && index) { activeGesture = "point"; setShape('fist'); }
            else if (count === 2 && index && middle) { activeGesture = "heart"; setShape('heart'); }
            else if (count === 3) { activeGesture = "triangle"; setShape('triangle'); }
            else { activeGesture = "sphere"; setShape('sphere'); }

            gestureLabel.innerText = activeGesture;
            document.getElementById('status').innerText = "TRACKING";
        }
    });

    const cam = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 480, height: 640, facingMode: "user"
    });
    cam.start();

    // --- RENDER LOOP ---
    function animate() {
        requestAnimationFrame(animate);
        const p = geometry.attributes.position.array;
        const c = geometry.attributes.color.array;
        
        for(let i=0; i<PARTICLE_COUNT; i++) {
            let idx = i*3;
            let tx = targetArr[idx] + hX;
            let ty = targetArr[idx+1] + hY;
            let tz = targetArr[idx+2];

            // Smoothly move to target
            p[idx] += (tx - p[idx]) * 0.12;
            p[idx+1] += (ty - p[idx+1]) * 0.12;
            p[idx+2] += (tz - p[idx+2]) * 0.12;

            // Update Colors based on gesture
            if(activeGesture === "heart") { c[idx]=1; c[idx+1]=0.2; c[idx+2]=0.5; } // Pink
            else if(activeGesture === "fist") { c[idx]=1; c[idx+1]=0.1; c[idx+2]=0.1; } // Red
            else if(activeGesture === "point") { c[idx]=1; c[idx+1]=1; c[idx+2]=0; } // Yellow
            else { c[idx]=0; c[idx+1]=1; c[idx+2]=1; } // Cyan
        }
        points.rotation.y += 0.005;
        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>
